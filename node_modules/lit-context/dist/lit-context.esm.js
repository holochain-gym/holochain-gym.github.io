import { __decorate } from 'tslib';
import { LitElement, html, property } from 'lit-element';

/**
 * Copyright (c) 2020 Dorian Cortes, Gary Valverde
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
class Context {
  constructor(initialValue) {
    this.value = initialValue;
    this.subscriptions = new Set();
  }

  getValue() {
    return this.value;
  }

  setValue(newValue) {
    var _this$subscriptions;

    const oldValue = this.value;
    this.value = newValue;
    (_this$subscriptions = this.subscriptions) === null || _this$subscriptions === void 0 ? void 0 : _this$subscriptions.forEach(subscription => subscription(newValue, oldValue));
  }

}

/**
 * Copyright (c) 2020 Dorian Cortes, Gary Valverde
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 *
 * @param initialValue
 * @return { Context }
 */

function createContext(initialValue) {
  const context = new Context(initialValue);
  return context;
}
function consumeContext(context, callback) {
  /**
   * Get the subscriptions to a context
   */
  const {
    subscriptions
  } = context;
  /**
   * Add the new subscription
   */

  subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.add(callback);
  /**
   *
   */

  callback(context === null || context === void 0 ? void 0 : context.getValue());
  return () => {
    subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.delete(callback);
  };
}

/**
 * Copyright (c) 2020 Dorian Cortes, Gary Valverde
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 * Context Provider
 * @class
 */

class ContextProvider extends LitElement {
  constructor() {
    super();
    this.value = {};
    this.context = createContext(this.value);
  }

  render() {
    this.context.setValue(this.value);
    return html`
      <slot></slot>
    `;
  }

}

__decorate([property({
  type: Context
})], ContextProvider.prototype, "context", void 0);

__decorate([property({
  type: Object
})], ContextProvider.prototype, "value", void 0);

/**
 * Copyright (c) 2020 Dorian Cortes, Gary Valverde
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 * Context Consumer
 * @param providerTag
 * @param consumer
 * @param mapFn
 */

const contextConsumer = (providerTag, consumer, mapFn) => {
  let provider = null;
  let node = consumer;

  do {
    var _node, _node4, _node6, _root;

    let slot = node.assignedSlot instanceof HTMLSlotElement;
    /**
     * Find the node's closest provider tag
     */

    provider = (_node = node) === null || _node === void 0 ? void 0 : _node.closest(providerTag);
    /**
     * If within a slot
     */

    let parentIsSlotted;

    if (slot && provider === null) {
      var _node2, _node2$assignedSlot;

      provider = ((_node2 = node) === null || _node2 === void 0 ? void 0 : (_node2$assignedSlot = _node2.assignedSlot) === null || _node2$assignedSlot === void 0 ? void 0 : _node2$assignedSlot.closest(providerTag)) || null;
      /**
       * If provider remains null
       */

      if (provider === null) {
        var _node3, _node3$parentElement;

        /**
         * Then check if the parent node of the slotted element is slotted as well
         */
        parentIsSlotted = ((_node3 = node) === null || _node3 === void 0 ? void 0 : (_node3$parentElement = _node3.parentElement) === null || _node3$parentElement === void 0 ? void 0 : _node3$parentElement.assignedSlot) instanceof HTMLSlotElement;
      }
    }
    /**
     * Find the root node
     */


    let root = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.getRootNode();
    /**
     * If within a slot
     */

    if (slot && root === null) {
      var _node5, _node5$assignedSlot;

      root = ((_node5 = node) === null || _node5 === void 0 ? void 0 : (_node5$assignedSlot = _node5.assignedSlot) === null || _node5$assignedSlot === void 0 ? void 0 : _node5$assignedSlot.getRootNode()) || null;
    }
    /**
     * Set the node to the root host
     */


    node = parentIsSlotted ? (_node6 = node) === null || _node6 === void 0 ? void 0 : _node6.parentElement : (_root = root) === null || _root === void 0 ? void 0 : _root.host;
  } while (!provider && node);
  /**
   * If there's a valid provider
   */


  if (provider) {
    /**
     * Register the context to be consumed
     */
    const unsubscribe = consumeContext(provider.context, (providerNewValue, providerOldValue) => {
      if (!consumer.isConnected) {
        unsubscribe();
      } else if (mapFn instanceof Function) {
        mapFn.call(consumer, providerNewValue, providerOldValue);
      } else {
        Object.assign(consumer, providerNewValue);
      }
    });
  }
};

/**
 * Copyright (c) 2020 Dorian Cortes, Gary Valverde
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
const consume = (providerTag, mapFn) => classOrDescriptor => typeof classOrDescriptor === 'function' ? legacyCustomElement(classOrDescriptor, providerTag, mapFn) : standardCustomElement(classOrDescriptor, providerTag, mapFn);

const legacyCustomElement = (classConstructor, providerTag, mapFn) => {
  const consumer = (consumer, mapFn) => contextConsumer(providerTag, consumer, mapFn);

  return class extends classConstructor {
    connectedCallback() {
      super.connectedCallback();
      consumer(this, mapFn);
    }

  };
};

const standardCustomElement = (classConstructor, providerTag, mapFn) => {
  const {
    kind,
    elements
  } = classConstructor;

  const consumer = (consumer, mapFn) => contextConsumer(providerTag, consumer, mapFn);

  return {
    kind,
    elements,

    finisher(clazz) {
      clazz.prototype.__litContextConnectedCallback = clazz.prototype.connectedCallback;

      clazz.prototype.connectedCallback = function connectedCallbackHandler() {
        this.__litContextConnectedCallback();

        consumer(this, mapFn);
      };
    }

  };
};

/**
 * Copyright (c) 2020 Dorian Cortes, Gary Valverde
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
/**
 * @param providerTagName Provider name (Note: It will be used to generate its custom element tag name)
 * @returns Context information and consume functionalities
 */

const createContext$1 = (providerName, defaultValue = {}) => {
  const tagName = providerName + '-provider';

  if (!customElements.get(tagName)) {
    customElements.define(tagName, class extends ContextProvider {
      constructor() {
        super(...arguments);
        this.value = defaultValue;
      }

    });
  }

  return {
    getTagName: () => tagName,
    consumer: (consumer, mapFn) => contextConsumer(tagName, consumer, mapFn),
    consume: mapFn => consume(tagName, mapFn)
  };
};

export { Context, ContextProvider, consume, contextConsumer, createContext$1 as createContext };
//# sourceMappingURL=lit-context.esm.js.map
